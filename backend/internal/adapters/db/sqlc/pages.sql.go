// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: pages.sql

package sqlc

import (
	"context"
)

const getPageBySlug = `-- name: GetPageBySlug :one
SELECT id, slug, title_ru, body_ru, title_en, body_en, updated_at FROM page_contents WHERE slug = $1
`

func (q *Queries) GetPageBySlug(ctx context.Context, slug string) (PageContent, error) {
	row := q.db.QueryRow(ctx, getPageBySlug, slug)
	var i PageContent
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.TitleRu,
		&i.BodyRu,
		&i.TitleEn,
		&i.BodyEn,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertPage = `-- name: UpsertPage :exec
INSERT INTO page_contents (slug, title_ru, body_ru, title_en, body_en)
VALUES ($1,$2,$3,$4,$5)
ON CONFLICT (slug) DO UPDATE SET
  title_ru = EXCLUDED.title_ru,
  body_ru = EXCLUDED.body_ru,
  title_en = EXCLUDED.title_en,
  body_en = EXCLUDED.body_en,
  updated_at = now()
`

type UpsertPageParams struct {
	Slug    string `json:"slug"`
	TitleRu string `json:"title_ru"`
	BodyRu  string `json:"body_ru"`
	TitleEn string `json:"title_en"`
	BodyEn  string `json:"body_en"`
}

func (q *Queries) UpsertPage(ctx context.Context, arg UpsertPageParams) error {
	_, err := q.db.Exec(ctx, upsertPage,
		arg.Slug,
		arg.TitleRu,
		arg.BodyRu,
		arg.TitleEn,
		arg.BodyEn,
	)
	return err
}
