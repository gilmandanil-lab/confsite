// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: talks.sql

package sqlc

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countTalksBySpeaker = `-- name: CountTalksBySpeaker :one
SELECT count(*) FROM talks WHERE speaker_user_id = $1
`

func (q *Queries) CountTalksBySpeaker(ctx context.Context, speakerUserID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countTalksBySpeaker, speakerUserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTalk = `-- name: CreateTalk :exec
INSERT INTO talks (
  speaker_user_id, section_id, title,
  affiliation, abstract, kind, authors
) VALUES ($1,$2,$3,$4,$5,$6,$7)
`

type CreateTalkParams struct {
	SpeakerUserID uuid.UUID   `json:"speaker_user_id"`
	SectionID     pgtype.UUID `json:"section_id"`
	Title         string      `json:"title"`
	Affiliation   string      `json:"affiliation"`
	Abstract      string      `json:"abstract"`
	Kind          string      `json:"kind"`
	Authors       []byte      `json:"authors"`
}

func (q *Queries) CreateTalk(ctx context.Context, arg CreateTalkParams) error {
	_, err := q.db.Exec(ctx, createTalk,
		arg.SpeakerUserID,
		arg.SectionID,
		arg.Title,
		arg.Affiliation,
		arg.Abstract,
		arg.Kind,
		arg.Authors,
	)
	return err
}

const listTalksBySpeaker = `-- name: ListTalksBySpeaker :many
SELECT id, speaker_user_id, section_id, title, affiliation, abstract, kind, authors, schedule_time, file_url, created_at FROM talks WHERE speaker_user_id = $1
`

func (q *Queries) ListTalksBySpeaker(ctx context.Context, speakerUserID uuid.UUID) ([]Talk, error) {
	rows, err := q.db.Query(ctx, listTalksBySpeaker, speakerUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Talk
	for rows.Next() {
		var i Talk
		if err := rows.Scan(
			&i.ID,
			&i.SpeakerUserID,
			&i.SectionID,
			&i.Title,
			&i.Affiliation,
			&i.Abstract,
			&i.Kind,
			&i.Authors,
			&i.ScheduleTime,
			&i.FileUrl,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTalksWithSections = `-- name: ListTalksWithSections :many
SELECT t.id, t.speaker_user_id, t.section_id, t.title, t.affiliation, t.abstract, t.kind, t.authors, t.schedule_time, t.file_url, t.created_at, s.title_ru, s.title_en, p.surname, p.name, p.patronymic, p.city
FROM talks t
LEFT JOIN sections s ON s.id = t.section_id
LEFT JOIN profiles p ON p.user_id = t.speaker_user_id
ORDER BY COALESCE(t.schedule_time, t.created_at), s.sort_order
`

type ListTalksWithSectionsRow struct {
	ID            uuid.UUID          `json:"id"`
	SpeakerUserID uuid.UUID          `json:"speaker_user_id"`
	SectionID     pgtype.UUID        `json:"section_id"`
	Title         string             `json:"title"`
	Affiliation   string             `json:"affiliation"`
	Abstract      string             `json:"abstract"`
	Kind          string             `json:"kind"`
	Authors       []byte             `json:"authors"`
	ScheduleTime  pgtype.Timestamptz `json:"schedule_time"`
	FileUrl       pgtype.Text        `json:"file_url"`
	CreatedAt     time.Time          `json:"created_at"`
	TitleRu       pgtype.Text        `json:"title_ru"`
	TitleEn       pgtype.Text        `json:"title_en"`
	Surname       pgtype.Text        `json:"surname"`
	Name          pgtype.Text        `json:"name"`
	Patronymic    pgtype.Text        `json:"patronymic"`
	City          pgtype.Text        `json:"city"`
}

func (q *Queries) ListTalksWithSections(ctx context.Context) ([]ListTalksWithSectionsRow, error) {
	rows, err := q.db.Query(ctx, listTalksWithSections)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTalksWithSectionsRow
	for rows.Next() {
		var i ListTalksWithSectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SpeakerUserID,
			&i.SectionID,
			&i.Title,
			&i.Affiliation,
			&i.Abstract,
			&i.Kind,
			&i.Authors,
			&i.ScheduleTime,
			&i.FileUrl,
			&i.CreatedAt,
			&i.TitleRu,
			&i.TitleEn,
			&i.Surname,
			&i.Name,
			&i.Patronymic,
			&i.City,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTalkSchedule = `-- name: UpdateTalkSchedule :exec
UPDATE talks 
SET section_id = $1, schedule_time = $2 
WHERE id = $3
`

type UpdateTalkScheduleParams struct {
	SectionID    pgtype.UUID        `json:"section_id"`
	ScheduleTime pgtype.Timestamptz `json:"schedule_time"`
	ID           uuid.UUID          `json:"id"`
}

func (q *Queries) UpdateTalkSchedule(ctx context.Context, arg UpdateTalkScheduleParams) error {
	_, err := q.db.Exec(ctx, updateTalkSchedule, arg.SectionID, arg.ScheduleTime, arg.ID)
	return err
}
